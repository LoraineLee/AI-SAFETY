import zodToJsonSchema from 'zod-to-json-schema';
import { LanguageModel, LanguageModelStreamPart } from '../language-model';
import { ChatPrompt } from '../prompt/chat-prompt';
import { InstructionPrompt } from '../prompt/instruction-prompt';
import { Tool } from '../tool';
import { ToolDefinition } from '../tool/tool-definition';
import { runToolsTransformation } from './run-tools-transformation';
import { StreamTextHttpResponse } from './stream-text-http-response';
import { ToolResultStreamPart } from './tool-result-stream-part';

/**
 * Stream text generated by a language model.
 */
export async function streamText({
  model,
  prompt,
  tools,
}: {
  model: LanguageModel;
  prompt: InstructionPrompt | ChatPrompt;
  tools?: Array<
    ToolDefinition<string, unknown> | Tool<string, unknown, unknown>
  >;
}): Promise<StreamTextResult> {
  const modelStream = await model.doStream({
    prompt,
    tools: tools?.map(tool => ({
      name: tool.name,
      description: tool.description,
      parameters: zodToJsonSchema(tool.parameters),
    })),
  });

  const toolStream = runToolsTransformation({
    tools,
    generatorStream: modelStream,
  });

  return new StreamTextResult(toolStream);
}

export class StreamTextResult {
  private readonly rootStream: ReadableStream<
    LanguageModelStreamPart | ToolResultStreamPart
  >;

  readonly textStream: AsyncIterable<string>;

  readonly fullStream: AsyncIterable<
    LanguageModelStreamPart | ToolResultStreamPart
  >;

  constructor(
    stream: ReadableStream<LanguageModelStreamPart | ToolResultStreamPart>,
  ) {
    this.rootStream = stream;

    this.textStream = {
      [Symbol.asyncIterator](): AsyncIterator<string> {
        const reader = stream.getReader();
        return {
          next: async () => {
            // loops until a text delta is found or the stream is finished:
            while (true) {
              const { done, value } = await reader.read();

              if (done) {
                return { value: null, done: true };
              }

              if (value.type === 'text-delta') {
                return { value: value.textDelta, done: false };
              }
            }
          },
        };
      },
    };

    this.fullStream = {
      [Symbol.asyncIterator](): AsyncIterator<
        LanguageModelStreamPart | ToolResultStreamPart
      > {
        const reader = stream.getReader();
        return {
          next: async () => {
            while (true) {
              const { done, value } = await reader.read();
              return done ? { value: null, done: true } : { value, done };
            }
          },
        };
      },
    };
  }

  toResponse() {
    return new StreamTextHttpResponse(this.rootStream);
  }
}
