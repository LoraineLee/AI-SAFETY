import { LanguageModel, LanguageModelStreamPart } from '../language-model';
import { LanguageModelPrompt } from '../prompt';
import { Tool } from '../tool';
import { ToolDefinition } from '../tool/tool-definition';
import { runToolsTransformation } from './run-tools-transformation';
import { StreamTextHttpResponse } from './stream-text-http-response';
import { ToolResultStreamPart } from './tool-result-stream-part';

/**
 * Stream text generated by a language model.
 */
export async function streamText({
  model,
  prompt,
  tools = [],
}: {
  model: LanguageModel;
  prompt: LanguageModelPrompt;
  tools?: Array<
    ToolDefinition<string, unknown> | Tool<string, unknown, unknown>
  >;
}): Promise<StreamTextResult> {
  const modelStream = await model.doStream({ prompt, tools });

  const toolStream = runToolsTransformation({
    tools,
    generatorStream: modelStream,
  });

  return new StreamTextResult(toolStream);
}

export class StreamTextResult {
  private readonly rootStream: ReadableStream<
    LanguageModelStreamPart | ToolResultStreamPart
  >;

  readonly textStream: AsyncIterable<string>;

  constructor(
    stream: ReadableStream<LanguageModelStreamPart | ToolResultStreamPart>,
  ) {
    this.rootStream = stream;

    this.textStream = {
      [Symbol.asyncIterator](): AsyncIterator<string> {
        const reader = stream.getReader();
        return {
          next: async () => {
            // loops until a text delta is found or the stream is finished:
            while (true) {
              const { done, value } = await reader.read();

              if (done) {
                return { value: null, done: true };
              }

              if (value.type === 'text-delta') {
                return { value: value.textDelta, done: false };
              }
            }
          },
        };
      },
    };
  }

  toResponse() {
    return new StreamTextHttpResponse(this.rootStream);
  }
}
